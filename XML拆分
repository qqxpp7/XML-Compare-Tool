# -*- coding: utf-8 -*-
"""
Created on Fri Jul 12 09:41:44 2024

@author: a9037
"""

import customtkinter as ctk
from tkinter import ttk
import tkinter as tk
import os
import random
import xml.etree.ElementTree as ET

# 創建主窗口
root = ctk.CTk()
root.title("XML Compare Tool")
root.geometry("1000x600")

"""
這是左邊功能列表
"""
# 功能列表
def on_function_button_click(function):
    selected_function.set(function)
    for widget in left_frame.winfo_children():
        if isinstance(widget, ctk.CTkButton) and widget.cget("text") in sum(categories.values(), []):
            widget.configure(fg_color="white", text_color="black")
    function_buttons[function].configure(fg_color="lightblue", text_color="black")

#建立左邊的功能列框架
left_frame = ctk.CTkFrame(root, width=200)
left_frame.pack(side="left", fill="y", padx=10, pady=10)

# 功能分類及功能列表
categories = {"":["搜尋"],
    "主功能": ["01 位置設定", "02 XML 拆分", "03 找出差異", "04 比對"],
    "其他功能": ["Copy 資料", "Element 分割"]
}

selected_function = tk.StringVar(value="02 XML 拆分")

function_buttons = {}
for category, functions in categories.items():
    if category:  # 如果類別有名稱，顯示類別標籤
        label = ctk.CTkLabel(left_frame, text=category, font=("Arial", 12, "bold"))
        label.pack(pady=5, anchor="center")
    for function in functions:
        button = ctk.CTkButton(left_frame, text=function, width=180, anchor="center", fg_color="white", text_color="black",
                               command=lambda f=function: on_function_button_click(f))
        button.pack(pady=5, anchor="center")
        function_buttons[function] = button
    # 根據類別新增分割線
    if category in ["", "主功能"]:
        line = ctk.CTkFrame(left_frame, height=2, fg_color="lightgray")
        line.pack(fill="x", pady=5)
        
# 設定初始選取項顏色為藍色
function_buttons["02 XML 拆分"].configure(fg_color="lightblue", text_color="black")

"""
以下為右邊畫面
"""
# 建立右邊的顯示框架
right_frame = ctk.CTkFrame(root)
right_frame.pack(side="right", fill="both", expand=True, padx=10, pady=10)

# 右上
top_right_frame = ctk.CTkFrame(right_frame)
top_right_frame.pack(pady=10, padx=10, fill="x")
# 右下
meddle_right_frame = ctk.CTkFrame(right_frame)
meddle_right_frame.pack(pady=10, padx=10, fill="both", expand=True)
# 右下
bottom_right_frame = ctk.CTkFrame(right_frame)
bottom_right_frame.pack(pady=10, padx=10, fill="both", expand=True)

# 初始化變數
before_button_var = tk.IntVar(value=1)
after_button_var = tk.IntVar(value=1)

# 新增預設輸入框 
def default_input(frame, row, label_text, entry_width,default_text):
    label = ctk.CTkLabel(bottom_right_frame, text=label_text, anchor="w")
    label.grid(row=row, column=0, pady=10, padx=50, sticky="w")
    entry = ctk.CTkEntry(bottom_right_frame, width=entry_width)
    entry.grid(row=row, column=1, sticky="w")
    entry.insert(0, default_text) # 預設 xml
    return entry

def load_xml_file(path):
    files = [f for f in os.listdir(path) if f.endswith('.xml')]
    if not files:
        return None
    return os.path.join(path, random.choice(files))

def on_dropdown_select(*args):
    folder_path = selected_option.get()  # 根據選擇的選項來設置資料夾路徑
    if folder_path == "All":
        folder_path = random.choice(["Before", "After"])
    file_path = load_xml_file(folder_path)
    if file_path:
        display_xml_content(file_path)
        
def display_xml_content(file_path):
    for widget in meddle_right_frame.winfo_children():
        widget.destroy()
    
    tree = ET.parse(file_path)
    root_element = tree.getroot()
    # Create a stack to manage the elements and their depth
    # stack = [(root_element, 0)]   
    # while stack:
    #     element, depth = stack.pop()
    #     indent = '  ' * depth
    #     print(f"{indent}{element.tag}: {element.text.strip() if element.text else 'None'}")
        
    #     # Add children to the stack with increased depth
    #     for child in reversed(element):
    #         stack.append((child, depth + 1))
    # row = 0
    # for child in root_element:
    #     label = ctk.CTkLabel(meddle_right_frame, text=f"<{child.tag}>", anchor="w")
    #     label.grid(row=row, column=0, pady=5, padx=5, sticky="w")
        
    #     if child.text and child.text.strip():
    #         value_label = ctk.CTkLabel(meddle_right_frame, text=child.text.strip(), anchor="w")
    #         value_label.grid(row=row, column=1, pady=5, padx=5, sticky="w")
    #     row += 1
        
def create_combobox():
    combobox = ttk.Combobox(top_right_frame, textvariable=selected_option, values=options)
    combobox.grid(row=5, column=0, pady=50, padx=50)
    selected_option.trace("w", on_dropdown_select)
    
# 下拉式選單的選項
options = ["All", "Before", "After"]
selected_option = tk.StringVar()
selected_option.set(options[0])

create_combobox()

split_element_entry=default_input(bottom_right_frame, 1, "拆分Element：", 400, "ns0:abap")
delimiter_entry=default_input(bottom_right_frame, 2, "分隔符號：", 200, "&")

# 流水號標籤
sequence_label = ctk.CTkLabel(bottom_right_frame, text="流水號：")
sequence_label.grid(row=3, column=0, pady=20, padx=50, sticky="w")
# 流水號選項
sequence_var = tk.StringVar(value="無")
sequence_options = ctk.CTkSegmentedButton(
    master=bottom_right_frame,
    values=["前面", "後面", "無"],
    variable=sequence_var,
)
sequence_options.grid(row=3, column=1, pady=10, padx=10, sticky="w")

#啟動主循環
root.mainloop()
